const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { PrismaClient } = require('@prisma/client');

const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
});

const app = express();
const server = http.createServer(app);
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Ð Ð°Ð·Ñ€ÐµÑˆÑ‘Ð½Ð½Ñ‹Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸ (CORS)
const allowedOrigins = [
  'http://localhost:5173',
  'https://alexkairo-ai.github.io' // Ð²Ð°Ñˆ Ð´Ð¾Ð¼ÐµÐ½ GitHub Pages
];

const io = new Server(server, {
  cors: {
    origin: allowedOrigins,
    methods: ['GET', 'POST'],
    credentials: true,
  },
});

app.use(cors({ origin: allowedOrigins, credentials: true }));
app.use(express.json());

// ==================== REST API (ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ) ====================

// Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ
app.post('/api/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    if (!username || !email || !password) {
      return res.status(400).json({ error: 'Ð’ÑÐµ Ð¿Ð¾Ð»Ñ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹' });
    }
    const existing = await prisma.user.findFirst({
      where: { OR: [{ email }, { username }] },
    });
    if (existing) {
      return res.status(400).json({ error: 'Email Ð¸Ð»Ð¸ username ÑƒÐ¶Ðµ Ð·Ð°Ð½ÑÑ‚Ñ‹' });
    }
    const passwordHash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({
      data: { username, email, passwordHash },
    });
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
    res.json({
      token,
      user: { id: user.id, username: user.username, email: user.email },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// Ð’Ñ…Ð¾Ð´
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) return res.status(401).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ email Ð¸Ð»Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ' });
    const valid = await bcrypt.compare(password, user.passwordHash);
    if (!valid) return res.status(401).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ email Ð¸Ð»Ð¸ Ð¿Ð°Ñ€Ð¾Ð»ÑŒ' });
    const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: '7d' });
    res.json({
      token,
      user: { id: user.id, username: user.username, email: user.email },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// Middleware Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ñ‚Ð¾ÐºÐµÐ½Ð°
const authenticate = (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader) return res.status(401).json({ error: 'Ð¢Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ' });
  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.userId = decoded.userId;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ‚Ð¾ÐºÐµÐ½' });
  }
};

// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ
app.get('/api/me', authenticate, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: { id: true, username: true, email: true },
    });
    res.json(user);
  } catch (err) {
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ==================== Ð­ÐÐ”ÐŸÐžÐ˜ÐÐ¢Ð« Ð”Ð›Ð¯ Ð”Ð Ð£Ð—Ð•Ð™ ====================

// ÐŸÐ¾Ð¸ÑÐº Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¿Ð¾ Ð½Ð¸ÐºÐ½ÐµÐ¹Ð¼Ñƒ (Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ)
app.get('/api/users/search', authenticate, async (req, res) => {
  try {
    const { q } = req.query;
    if (!q) return res.json([]);
    const users = await prisma.user.findMany({
      where: {
        username: { contains: q, mode: 'insensitive' },
        NOT: { id: req.userId }
      },
      take: 10,
      select: { id: true, username: true }
    });
    res.json(users);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð² Ð´Ñ€ÑƒÐ·ÑŒÑ
app.post('/api/friends/request', authenticate, async (req, res) => {
  try {
    const { username } = req.body;
    if (!username) return res.status(400).json({ error: 'ÐÐµ ÑƒÐºÐ°Ð·Ð°Ð½ username' });

    // ÐÐ°Ñ…Ð¾Ð´Ð¸Ð¼ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÐµÐ»Ñ
    const receiver = await prisma.user.findUnique({ where: { username } });
    if (!receiver) return res.status(404).json({ error: 'ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });

    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ð½ÐµÑ‚ Ð»Ð¸ ÑƒÐ¶Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð¸Ð»Ð¸ Ð´Ñ€ÑƒÐ¶Ð±Ñ‹
    const existing = await prisma.friend.findFirst({
      where: {
        OR: [
          { senderId: req.userId, receiverId: receiver.id },
          { senderId: receiver.id, receiverId: req.userId }
        ]
      }
    });
    if (existing) {
      return res.status(400).json({ error: 'Ð—Ð°Ð¿Ñ€Ð¾Ñ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚ Ð¸Ð»Ð¸ Ð²Ñ‹ ÑƒÐ¶Ðµ Ð´Ñ€ÑƒÐ·ÑŒÑ' });
    }

    await prisma.friend.create({
      data: {
        senderId: req.userId,
        receiverId: receiver.id,
        status: 'pending'
      }
    });
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð´Ñ€ÑƒÐ·ÐµÐ¹ (ÑÐ¾ ÑÑ‚Ð°Ñ‚ÑƒÑÐ¾Ð¼ accepted)
app.get('/api/friends', authenticate, async (req, res) => {
  try {
    const friends = await prisma.friend.findMany({
      where: {
        OR: [
          { senderId: req.userId, status: 'accepted' },
          { receiverId: req.userId, status: 'accepted' }
        ]
      },
      include: {
        sender: { select: { id: true, username: true } },
        receiver: { select: { id: true, username: true } }
      }
    });
    const result = friends.map(f => 
      f.senderId === req.userId ? f.receiver : f.sender
    );
    res.json(result);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹ (pending)
app.get('/api/friends/requests', authenticate, async (req, res) => {
  try {
    const requests = await prisma.friend.findMany({
      where: { receiverId: req.userId, status: 'pending' },
      include: { sender: { select: { id: true, username: true } } }
    });
    res.json(requests.map(r => r.sender));
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ÐŸÑ€Ð¸Ð½ÑÑ‚ÑŒ Ð¸Ð»Ð¸ Ð¾Ñ‚ÐºÐ»Ð¾Ð½Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ñ€Ð¾Ñ
app.put('/api/friends/respond/:id', authenticate, async (req, res) => {
  try {
    const { status } = req.body; // 'accepted' Ð¸Ð»Ð¸ 'rejected'
    if (!['accepted', 'rejected'].includes(status)) {
      return res.status(400).json({ error: 'ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ ÑÑ‚Ð°Ñ‚ÑƒÑ' });
    }
    const senderId = parseInt(req.params.id);

    const friend = await prisma.friend.findFirst({
      where: {
        senderId,
        receiverId: req.userId,
        status: 'pending'
      }
    });
    if (!friend) return res.status(404).json({ error: 'Ð—Ð°Ð¿Ñ€Ð¾Ñ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½' });

    await prisma.friend.update({
      where: { id: friend.id },
      data: { status }
    });
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°' });
  }
});

// ==================== SOCKET.IO (Ð§Ð°Ñ‚) ====================

// ÐÑƒÑ‚ÐµÐ½Ñ‚Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ ÑÐ¾ÐºÐµÑ‚Ð° Ñ‡ÐµÑ€ÐµÐ· Ñ‚Ð¾ÐºÐµÐ½
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  if (!token) return next(new Error('Authentication error'));
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    socket.userId = decoded.userId;
    next();
  } catch (err) {
    next(new Error('Invalid token'));
  }
});

io.on('connection', async (socket) => {
  console.log('âœ… ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ:', socket.id);

  // ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð¸Ð· Ð‘Ð”
  const user = await prisma.user.findUnique({
    where: { id: socket.userId },
    select: { id: true, username: true },
  });
  if (!user) return socket.disconnect();

  socket.on('join', async ({ room }) => {
    socket.join(room);
    socket.data = { userId: user.id, username: user.username, room };

    // Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹ (Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 50)
    const messages = await prisma.message.findMany({
      where: { room },
      orderBy: { createdAt: 'asc' },
      take: 50,
      include: { user: { select: { username: true } } },
    });

    socket.emit('history', messages.map(msg => ({
      id: msg.id,
      user: msg.user.username,
      text: msg.text,
      time: msg.createdAt,
    })));

    socket.to(room).emit('user-joined', `${user.username} Ð²Ð¾ÑˆÑ‘Ð» Ð² Ñ‡Ð°Ñ‚`);
  });

  socket.on('message', async (text) => {
    const socketUser = socket.data;
    if (!socketUser) return;

    const msg = await prisma.message.create({
      data: {
        room: socketUser.room,
        text,
        userId: socketUser.userId,
      },
      include: { user: { select: { username: true } } },
    });

    io.to(socketUser.room).emit('message', {
      id: msg.id,
      user: msg.user.username,
      text: msg.text,
      time: msg.createdAt,
    });
  });

  socket.on('disconnect', () => {
    const socketUser = socket.data;
    if (socketUser) {
      io.to(socketUser.room).emit('user-left', `${socketUser.username} Ð¿Ð¾ÐºÐ¸Ð½ÑƒÐ» Ñ‡Ð°Ñ‚`);
    }
  });
});

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log(`\nðŸš€ Ð¡ÐµÑ€Ð²ÐµÑ€ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð° Ð¿Ð¾Ñ€Ñ‚Ñƒ ${PORT}`);
});
